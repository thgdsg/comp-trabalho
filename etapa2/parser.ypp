%{
// parser
// Thiago dos Santos Gonçalves - 00344587
// Semestre 2025/1
#include <stdio.h>
#include <stdlib.h>
#include <string>
using namespace std;
int yylex();
void yyerror(string msg);

// TROCAR POR TIPO DO IDENTIFICADOR, DEIXAR NO SCANNER
#define SYMBOL_INT_FUNC 1
#define SYMBOL_REAL_FUNC 2
#define SYMBOL_BYTE_FUNC 3
#define SYMBOL_INT_LIT 4
#define SYMBOL_REAL_LIT 5
#define SYMBOL_STRING_LIT 6
#define SYMBOL_CHAR_LIT 7
#define SYMBOL_INT_ID 8
#define SYMBOL_REAL_ID 9
#define SYMBOL_BYTE_ID 10
#define SYMBOL_INT_ARRAY 11
#define SYMBOL_REAL_ARRAY 12
#define SYMBOL_BYTE_ARRAY 13

%}
%locations
%token KW_BYTE
%token KW_INT
%token KW_REAL
%token KW_IF
%token KW_ELSE
%token KW_DO
%token KW_WHILE
%token KW_READ
%token KW_PRINT
%token KW_RETURN
%token OPERATOR_EQ
%token OPERATOR_LE
%token OPERATOR_GE
%token OPERATOR_DIF
%token TK_IDENTIFIER
%token LIT_INT
%token LIT_CHAR
%token LIT_REAL
%token LIT_STRING
%token TOKEN_ERROR

%left '&' '|'
%left '>' '<' OPERATOR_EQ OPERATOR_LE OPERATOR_GE OPERATOR_DIF
%left '+' '-'
%left '*' '/'
%left '~'

%%

program: ldef
    ;

// o programa é uma sequência de definições

ldef: def ldef
    |
    ;

// definições podem ser blocos de comando, declarações de variáveis, funções ou vetores
def: cmdl
    | vardec
    | fundec
    | vecdec

// todos os literais possiveis
lit: LIT_INT
    | LIT_CHAR
    | LIT_REAL
    | LIT_STRING
    ;

// todas as keywords de valores possiveis
kw_value: KW_INT
    | KW_REAL
    | KW_BYTE
    ;

// declaração de variáveis
vardec: kw_value TK_IDENTIFIER '=' lit ';'
    ;

// declaração de vetores
vecdec: kw_value TK_IDENTIFIER '[' LIT_INT ']' '=' listvar ';'
    | kw_value TK_IDENTIFIER '[' LIT_INT ']' ';'
    ;

// lista de variaveis (pra declaração de vetores)
listvar: lit ',' listvar
    | lit
    ;

// declaração de funções
fundec: kw_value TK_IDENTIFIER '(' argl ')' cmd
    ;

// lista de argumentos (para declaração de funções (não pra chamadas))
argl: arg ',' argl
    | arg
    ;

arg: kw_value TK_IDENTIFIER
    | 
    ;

// bloco de comandos
cmdblock: '{' cmdl '}'
    | '{' '}'
    ;

// lista de comandos (pra blocos de comandos)
cmdl: cmd cmdl
    | cmd
    ;

// comandos da linguagem
cmd: TK_IDENTIFIER '=' expr ';'
    | vec '=' expr ';'
    | KW_IF '(' expr ')' cmd
    | KW_IF '(' expr ')' cmd KW_ELSE cmd
    | KW_WHILE expr KW_DO cmd
    | KW_DO cmd KW_WHILE expr ';'
    | KW_READ TK_IDENTIFIER ';'
    | KW_PRINT printl ';'
    | KW_RETURN expr ';'
    | ';'
    | cmdblock
    ;

// lista de argumentos pro comando print
printl: expr printl
    | expr
    ;

// expressões da linguagem
expr: TK_IDENTIFIER
    | lit
    | vec
    | A operator B
    | funcall
    | kw_value TK_IDENTIFIER '(' ')'
    ;

// lista de expressões (para chamada de função)
exprlist: expr ',' exprlist
    | expr
    |
    ;

// operadores aceitos pela linguagem
operator: '+'
    | '-'
    | '*'
    | '/'
    | '>'
    | '<'
    | '&'
    | '|'
    | '~'
    | OPERATOR_EQ
    | OPERATOR_LE
    | OPERATOR_GE
    | OPERATOR_DIF
    ;

// vetores (generalizando)
vec: TK_IDENTIFIER '[' expr ']'
    | TK_IDENTIFIER '[' ']'
    ;

// chamada de função
funcall: TK_IDENTIFIER '(' exprlist ')'
    ;

//operadores A e B pra expressões
A: TK_IDENTIFIER
    | LIT_INT
    | LIT_CHAR
    | LIT_REAL
    | LIT_STRING
    | vec
    ;

B: TK_IDENTIFIER
    | LIT_INT
    | LIT_CHAR
    | LIT_REAL
    | LIT_STRING
    | vec
    ;

%%

void yyerror(string msg){
    extern YYLTYPE yylloc;
    fprintf(stderr, "Erro de sintaxe na linha %d: %s\n", yylloc.first_line, msg.c_str());
    exit(3);
}